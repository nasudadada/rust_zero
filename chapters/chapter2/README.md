### 真偽値型
bool: trueか、falseの値を取りうる
短絡評価と非短絡評価がある。基本的に非短絡評価で良い

### 整数型
Rustでは、符号なし整数（unsigned integer）と符号付き整数(signed　integer)で区別される。
u8(符号なし) i8（符号あり）
→ デフォルト？で `1-2` とかやると `-1` になるから、符号ありがデフォ？

### 浮動小数点型
- 浮動小数点数は IEEE754 の仕様に従っている

### ビット演算
システムプログラミングや高効率な実装を行う際に必要となる。

#### 論理シフト（logical shift）
- ビットを単純に左または右にずらす操作
- 空いたビットには必ず `0` が入る
- 符号（正負）は考慮しない
- 主に符号なし整数で使われる

例（8ビットで考える）:
```rust
// 元の値
0b1011_0110
// 右に1ビット論理シフト（>>）
0b0101_1011  // 右端に落ちたビットは消え、左端には0が入る
```

#### 算術シフト（arithmetic shift）
- ビットを左または右にずらす操作だが、符号（最上位ビット）を維持する
- 右シフトの場合、空いた左端には元の符号ビット（最上位ビット）が入る
- 主に符号付き整数で使われる

例（8ビットで考える）:
```rust
// 符号付き、最上位ビット1は負の数
0b1011_0110
// 右に1ビット算術シフト
// 左端（符号ビット）は1のまま
```

#### 違いのまとめ

| シフト種類   | 左端の空きビット | 用途           | 符号維持 |
|:------------|:----------------|:---------------|:---------|
| 論理シフト   | 0               | 符号なし整数   | しない   |
| 算術シフト   | 符号ビット       | 符号付き整数   | する     |

#### Rustの場合
- `>>` は型によって自動的に論理シフト（符号なし型）か算術シフト（符号付き型）になる。
  - `u8`, `u32` などは論理シフト
  - `i8`, `i32` などは算術シフト
